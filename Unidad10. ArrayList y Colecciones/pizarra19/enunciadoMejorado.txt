
# üß™ PR√ÅCTICA DE PROGRAMACI√ìN EN JAVA 

## Gesti√≥n de una Liga de Videojuegos

### üìå OBJETIVO GENERAL
Crear una aplicaci√≥n de gesti√≥n para una liga de eSports que permita administrar jugadores, 
sus estad√≠sticas y realizar mantenimientos de la lista mediante un men√∫ interactivo.

---

## üèóÔ∏è 1. ESTRUCTURA DE CLASES (MODELO)

### üîπ 1.1 Emumerado: `RolJugador`
Valores: 
* `DPS`
* `TANQUE`
* `SOPORTE`

### üîπ 1.2 Interfaz: `Competidor`
Crea una **interfaz** con los siguientes m√©todos:
* `int calcularPuntuacion()`
* `boolean esProfesional()`

### üîπ 1.3 Clase Abstracta: `Jugador`
* **Comportamiento**: Implementa la interfaz `Competidor`.
* **Atributos**: `nombre` (String), `rol` (RolJugador), `nivel` (int), `partidasJugadas` (int).

#### M√©todos:
* **Constructor**, Getters y Setters.
* `abstract void entrenar()`
* `toString()`: Sobrescrito para mostrar datos.
* `equals() y hashCode()`: Dos jugadores son iguales si tienen el mismo **nombre** (ignora may√∫sculas) y **rol**.

#### Implementaci√≥n de Competidor:
* `calcularPuntuacion()`: Devuelve `nivel * partidasJugadas`.
* `esProfesional()`: Implementaci√≥n base que devuelve `false`.

#### Sobrecarga de M√©todos:
* `subirNivel()`: Incrementa nivel en 1.
* `subirNivel(int cantidad)`: Incrementa nivel en `cantidad`.

### üîπ 1.4 Clases Concretas

#### **`JugadorAmateur`**
* **Atributo extra**: `boolean juegaPorDiversion`.
* `entrenar()`: Nivel + 1. 
* `esProfesional()`: Devuelve `false` (puede usar la de la clase padre).
* `calcularPuntuacion()`: Sobrescribe para devolver **Base + 10**.

#### **`JugadorProfesional`**
* **Atributo extra**: `double salario`.
* `entrenar()`: Nivel + 2. 
* `esProfesional()`: Sobrescribe para devolver `true`.
* `calcularPuntuacion()`: Sobrescribe para devolver **Base + 50**.

---

## üéÆ 2. CLASE PRINCIPAL (`PruebaJugador`)

El programa debe basarse en un √∫nico **MEN√ö INTERACTIVO** que englobe todas las funcionalidades. 
Al iniciar, el programa crea una lista `ArrayList<Jugador>` vac√≠a.

### üìã Men√∫ de Opciones:

#### **1Ô∏è‚É£ Cargar Datos de Prueba**
* Limpia la lista actual.
* A√±ade autom√°ticamente **2 jugadores Amateur** y **2 Profesionales** predefinidos.
* Muestra cu√°ntos jugadores hay en la liga (`size`).

#### **2Ô∏è‚É£ Listar Jugadores**
* Recorre la lista (`foreach`) y muestra cada jugador.

#### **3Ô∏è‚É£ Realizar Entrenamiento de Temporada (Polimorfismo + instanceof)**
* Recorre la lista.
* Si el jugador es **Profesional** (`instanceof`), ejecuta su m√©todo `entrenar()` y avisa por consola.
* Si es **Amateur**, imprime: "El jugador [nombre] es amateur y no entrena en esta sesi√≥n".

#### **4Ô∏è‚É£ Gesti√≥n Individual (Get/Set/Sobrecarga)**
Permite elegir una sub-acci√≥n:
* **Modificar (Set)**: Pide posici√≥n y cambia el jugador por uno nuevo (pide datos b√°sicos).
* **Consultar (Get)**: Pide posici√≥n y muestra datos.
* **Entrenamiento Personalizado (Sobrecarga)**: Pide posici√≥n de un jugador. Pregunta si quiere 
subir 1 nivel (llama a `subirNivel()`) o varios (pide cantidad y llama a `subirNivel(int)`).

#### **5Ô∏è‚É£ B√∫squeda y Duplicados (Contains + Equals)**
* **Buscar**: Pide un nombre, crea un jugador temporal y usa `contains` para comprobar si existe.
* **Informe de Duplicados**: Usa **bucles anidados** para comparar todos contra todos. Si encuentra dos jugadores 
iguales (seg√∫n `equals`), imprime: "‚ö†Ô∏è ALERTA: [Nombre] est√° duplicado".

#### **6Ô∏è‚É£ Mantenimiento de Liga (RemoveIf)**
* Elimina de la lista a todos los jugadores que **NO** sean profesionales (es decir, elimina amateurs).
* Muestra mensaje confirmando cu√°ntos quedan.

#### **0Ô∏è‚É£ Salir**
* Termina la ejecuci√≥n del programa.

---

### üí° Justificaci√≥n del Dise√±o
Esta estructura integra todos los conceptos (colecciones, l√≥gica de bucles, interacci√≥n de usuario, POO) en un flujo de trabajo coherente, evitando bloques de c√≥digo sueltos "antes" o "despu√©s" del men√∫ principal.
