Acabamos de ver equals, hashcode, clases y m√©todos abstractos y vamos a hacer este ejercicio:

El Reto: "Gesti√≥n de Stock Tecnol√≥gico"
Vas a programar el sistema de inventario de una tienda.

1. El coraz√≥n del sistema (Clase Abstracta)
Crea una clase abstracta Componente:

Atributos: String modelo, String numeroSerie (tu clave √∫nica), double precioBase.

M√©todo Abstracto: void imprimirDetalles(). Cada componente se muestra de forma 
distinta.

M√©todo equals y hashCode: Implementalo con vs code

2. La Herencia (Clases Hijas)
Crea dos clases que hereden de Componente:

Procesador: A√±ade int numNucleos.

DiscoDuro: A√±ade int capacidadGB.

üí° El truco para evitar instanceof: Al sobreescribir imprimirDetalles() 
en cada hija, cuando recorras la lista, 
cada objeto sabr√° qu√© decir de s√≠ mismo sin que t√∫ tengas que preguntar 
"¬øEres un Procesador?".

3. La Colecci√≥n (ArrayList)
En tu clase Main:

Crea un ArrayList<Componente> stock.

Validaci√≥n de duplicados: Antes de a√±adir un componente, usa 
stock.contains(nuevo) para avisar si el producto 
ya existe (esto probar√° tu equals).

Comparaci√≥n secuencial: Recorre el ArrayList con un bucle for 
(el de √≠ndice i) y compara si un componente es igual al siguiente. 
Si lo son, imprime un aviso.

Recorrido Final: Usa un foreach para llamar a imprimirDetalles() de todos los productos. Aqu√≠ ver√°s el polimorfismo en acci√≥n: cada uno imprimir√° sus propios atributos (n√∫cleos o capacidad) sin usar instanceof.

¬øC√≥mo probar que el equals y la jerarqu√≠a funcionan?
Diles que intenten hacer esto en el main:

Crear un Procesador con serie "ABC-123".

Crear un DiscoDuro con serie "ABC-123".

Si hacen procesador.equals(disco), debe dar FALSE (porque aunque el n√∫mero de serie coincida, las clases son distintas). Esto es lo que logramos con el getClass() != obj.getClass() que vimos antes.


