
# üß™ PR√ÅCTICA DE PROGRAMACI√ìN EN JAVA

## Gesti√≥n de una Liga de Videojuegos

### üìå Instrucciones generales

* Usa `ArrayList` para la gesti√≥n de colecciones.
* Todos los atributos deben ser **private**.
* El programa debe ejecutarse desde una clase `Main`.

---

## üß© CONTEXTO GENERAL

Se desea desarrollar un sistema de gesti√≥n para una **liga de videojuegos** en la que participan distintos tipos de jugadores.
Cada jugador tiene un rol, estad√≠sticas y un comportamiento com√∫n, pero existen diferencias seg√∫n su tipo.

---

## 1Ô∏è‚É£ ENUM ‚Äì Rol del jugador

Crea un `enum` llamado **RolJugador** con **√∫nicamente** los siguientes valores:

* `DPS`
* `TANQUE`
* `SOPORTE`

---

## 2Ô∏è‚É£ INTERFAZ ‚Äì Competidor

Crea una **interfaz** llamada `Competidor` con los siguientes m√©todos:

* `int calcularPuntuacion()`
* `boolean esProfesional()`

---

## 3Ô∏è‚É£ CLASE ABSTRACTA ‚Äì Jugador

Crea una **clase abstracta** llamada `Jugador` que:

### Atributos privados:

* `String nombre`
* `RolJugador rol`
* `int nivel`
* `int partidasJugadas`

### Requisitos:

* Constructor con todos los atributos
* Getters y setters
* Implementa la interfaz `Competidor`
* Declara un m√©todo abstracto: public abstract void entrenar();


### M√©todos:

* Sobrecarga el m√©todo `toString()` para mostrar toda la informaci√≥n del jugador.
* Sobrecarga `equals()` y `hashCode()`:

  * Dos jugadores son iguales si su **nombre coincide ignorando may√∫sculas/min√∫sculas** (`equalsIgnoreCase`) y tienen el mismo rol.
* Implementa `calcularPuntuacion()` de forma gen√©rica:  nivel * partidasJugadas

---

## 4Ô∏è‚É£ HERENCIA Y POLIMORFISMO

Crea dos clases hijas:

### üîπ JugadorAmateur

* A√±ade el atributo:

  * `boolean juegaPorDiversion`
* Implementa `entrenar()`:

  * Aumenta el nivel en 1
* Implementa `esProfesional()` devolviendo `false`
* Sobrescribe `calcularPuntuacion()`: Devuelve la puntuaci√≥n base + 10

---

### üîπ JugadorProfesional

* A√±ade el atributo:

  * `double salario`
* Implementa `entrenar()`: Aumenta el nivel en 2
* Implementa `esProfesional()` devolviendo `true`
* Sobrescribe `calcularPuntuacion()`: Devuelve la puntuaci√≥n base + 50

---

## 5Ô∏è‚É£ ARRAYLIST DE OBJETOS

En la clase `Main`:

1. Crea un `ArrayList<Jugador>` llamado `liga`.

2. A√±ade al menos:

   * 2 jugadores amateur
   * 2 jugadores profesionales
     *(usa `add`)*

3. Muestra:

   * El tama√±o de la lista (`size`)
   * Todos los jugadores usando un `foreach`

---

## 6Ô∏è‚É£ instanceof y POLIMORFISMO

En un recorrido `foreach` de la lista:

* Comprueba con `instanceof` si el jugador es `JugadorProfesional`
* Si lo es:

  * Llama a su m√©todo `entrenar()`
* Si no:

  * Muestra un mensaje indicando que es amateur

---

## 7Ô∏è‚É£ COMPARACI√ìN DE OBJETOS EN FOREACH (OBLIGATORIO)

En **otro `foreach`**, realiza lo siguiente:

* Guarda una referencia al **jugador anterior**
* Para cada jugador actual:

  * Comp√°ralo con el anterior usando `equals()`
  * Si son iguales, muestra un mensaje indicando que hay un duplicado
* El primer jugador no se compara

---

## 8Ô∏è‚É£ OPERACIONES CON ARRAYLIST

Implementa las siguientes operaciones:

1. Comprueba si la lista contiene un jugador concreto (`contains`)
2. Modifica un jugador existente usando `set`
3. Obt√©n un jugador por posici√≥n usando `get`
4. Elimina jugadores amateur usando: removeIf(...)
5. Muestra la lista final tras las eliminaciones

---

## 9Ô∏è‚É£ SOBRECARGA DE M√âTODOS

En la clase `Jugador`, sobrecarga un m√©todo llamado `subirNivel`:

* `subirNivel()`: sube 1 nivel
* `subirNivel(int cantidad)`: sube tantos niveles como se indique

Utiliza ambos m√©todos en el `Main`.

---

## üîü SALIDA FINAL

El programa debe mostrar:

* Estado inicial de la liga
* Cambios tras entrenamientos
* Detecci√≥n de jugadores duplicados
* Lista final tras eliminaciones

