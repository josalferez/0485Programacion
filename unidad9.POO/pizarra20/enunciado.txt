# üß™ PR√ÅCTICA DE PROGRAMACI√ìN EN JAVA 

## Gesti√≥n de un Torneo de Robots de Combate

### üìå OBJETIVO GENERAL
Crear una aplicaci√≥n de gesti√≥n para un torneo de robots que permita 
administrar participantes, 
sus estad√≠sticas y realizar mantenimientos de la lista mediante un 
men√∫ interactivo.

---

## üèóÔ∏è 1. ESTRUCTURA DE CLASES (MODELO)

### üîπ 1.1 Enumerado: `TipoRobot`
Valores: 
* `ATAQUE`
* `DEFENSA`
* `SOPORTE`

### üîπ 1.2 Interfaz: `Competidor`
Crea una **interfaz** con los siguientes m√©todos:
* `int calcularPuntuacion()`
* `boolean esProfesional()`

### üîπ 1.3 Clase Abstracta: `Robot`
* **Comportamiento**: Implementa la interfaz `Competidor`.
* **Atributos privados**: `id` (String), `tipo` (TipoRobot), `nivel` (int),
 `combatesRealizados` (int).

#### M√©todos:
* **Constructor**, Getters y Setters.
* `abstract void actualizarSoftware()`
* `toString()`: Sobrescrito para mostrar toda la informaci√≥n.
* `equals() y hashCode()`: Dos robots son iguales si tienen el mismo **id** (ignora may√∫sculas) y **tipo**.

#### Implementaci√≥n de Competidor:
* `calcularPuntuacion()`: Devuelve `nivel * combatesRealizados`.

#### Sobrecarga de M√©todos:
* `public void mejorarNivel()`: Incrementa nivel en 1.
* `public void mejorarNivel(int cantidad)`: Incrementa nivel en `cantidad`.

### üîπ 1.4 Clases Concretas que heredan de Robot

#### **`RobotEntrenamiento`**
* **Atributo extra**: `boolean usoEducativo`.
* `actualizarSoftware()`: Nivel + 1. 
* `esProfesional()`: Devuelve `false`.
* `calcularPuntuacion()`: Sobrescribe para devolver **Base + 10**.

#### **`RobotCompeticion`**
* **Atributo extra**: `double presupuesto`.
* `actualizarSoftware()`: Nivel + 2. 
* `esProfesional()`: Devuelve `true`.
* `calcularPuntuacion()`: Sobrescribe para devolver **Base + 50**.

---

## üéÆ 2. CLASE PRINCIPAL (`PruebaRobot.java`)

El programa debe basarse en un √∫nico **MEN√ö INTERACTIVO** que englobe 
todas las funcionalidades. 
Al iniciar, el programa crea una lista `ArrayList<Robot>` que se llama 
torneo vac√≠a.

### üìã Men√∫ de Opciones:

#### **1Ô∏è‚É£ Cargar Datos de Prueba**
* Limpia la lista actual.
* A√±ade autom√°ticamente **2 robots de Entrenamiento** y **2 de Competici√≥n** predefinidos.
* Muestra cu√°ntos robots hay en el torneo (`size`).

#### **2Ô∏è‚É£ Listar Robots**
* Recorre la lista (`foreach`) y muestra cada robot.

#### **3Ô∏è‚É£ Actualizar Software (Polimorfismo + instanceof)**
* Recorre la lista.
* Si el robot es **de Competici√≥n** (`instanceof`), ejecuta su m√©todo
 `actualizarSoftware()` y avisa por consola.
* Si es **de Entrenamiento**, imprime un mensaje indicando que no se actualiza en esta fase.

#### **4Ô∏è‚É£ Gesti√≥n Individual (Get/Set/Sobrecarga)**
Permite elegir una sub-acci√≥n:
* **Modificar (Set)**: Pide posici√≥n y cambia el robot por uno nuevo (pide datos b√°sicos).
* **Consultar (Get)**: Pide posici√≥n y muestra datos.
* **Mejora Personalizada (Sobrecarga)**: Pide posici√≥n de un robot. Pregunta si quiere subir 1 nivel (llama a `mejorarNivel()`) o varios (pide cantidad y llama a `mejorarNivel(int)`).

#### **5Ô∏è‚É£ B√∫squeda y Duplicados (Contains + Equals)**
* **Buscar**: Pide un ID y Tipo, crea un robot temporal y usa `contains` para comprobar si existe.
* **Informe de Duplicados**: Usa **bucles anidados** para comparar todos contra todos. Si encuentra dos robots iguales (seg√∫n `equals`), imprime: "‚ö†Ô∏è ALERTA: Robot [ID] est√° duplicado".

#### **6Ô∏è‚É£ Mantenimiento de Torneo (RemoveIf)**
* Elimina de la lista a todos los robots que **NO** sean profesionales (es decir, elimina los de entrenamiento).
* Muestra mensaje confirmando cu√°ntos quedan.

#### **0Ô∏è‚É£ Salir**
* Termina la ejecuci√≥n del programa.

---

### üí° Justificaci√≥n del Dise√±o
Esta estructura integra todos los conceptos (colecciones, l√≥gica de bucles, interacci√≥n de usuario, POO) en un flujo de trabajo coherente, evitando bloques de c√≥digo sueltos "antes" o "despu√©s" del men√∫ principal.
